---
title: "[Swift] åˆæœŸå€¤ãŒ nil ã® CurrentValueSubject ã§ nil ä»¥å¤–ã®å€¤ãŒãã‚‹ã¾ã§ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®šã™ã‚‹æ–¹æ³•"
emoji: "ğŸ”–"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Swift","Combine"]
published: true
---
# ã‚„ã‚ŠãŸã„ã“ã¨

åˆæœŸå€¤ãŒ nil ã® CurrentValueSubject ã«ã¤ã„ã¦ nil ä»¥å¤–ã®å€¤ãŒãã‚‹ã¾ã§ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®šã™ã‚‹ã“ã¨ã€‚
ç’°å¢ƒï¼šXcode 12.5.1

# çµè«–

åˆæœŸå€¤ãŒ nil ã® CurrentValueSubject ã«ã¤ã„ã¦ nil ä»¥å¤–ã®å€¤ãŒãã‚‹ã¾ã§ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®šã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®é †ã§å‡¦ç†ã—ã¦ã‚ã’ã‚‹ã¨ã†ã¾ãã„ãã¾ã™ã€‚

1. `compactMap()`
2. `first()`
3. `timeout()` 

```swift:ã‚µãƒ³ãƒ—ãƒ«
import Combine
import Foundation

enum TestError: Error {
    case minusError
    case nilError
    case timeoutError
    case otherError
}

func twice(num: Int) -> Int {
    return num * 2
}

var cancellables = Set<AnyCancellable>()

var subjectL = CurrentValueSubject<Int?, Never>(nil)
subjectL
    .compactMap { $0 } // â† nilã‚’æ’é™¤
    .first() // â† nil ä»¥å¤–ã®å€¤ãŒãã‚Œã° completion ãŒå‘¼ã°ã‚Œã‚‹
    .setFailureType(to: TestError.self) // â† timeout ã® Failure ã‚’è¨­å®šã—ã¦ã‚ã’ã‚‹
    .timeout(
        .seconds(3), // ä»Šå›ã¯3ç§’ã§è¨­å®š
        scheduler: DispatchQueue.main,
        options: nil,
        customError: { .timeoutError }
    )
    .flatMap { num -> AnyPublisher<Int, TestError> in
        guard num > 0 else {
            return Fail(error: TestError.minusError)
                .eraseToAnyPublisher()
        }
        return Just(num)
            .setFailureType(to: TestError.self)
            .eraseToAnyPublisher()
    }
    .map { twice(num: $0) }
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \($0)")
    }
    .store(in: &cancellables)

subjectL.send(nil) // â† å³æ™‚å®Ÿè¡Œ
DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
    subjectL.send(5) // â† ãã®2ç§’å¾Œã«å®Ÿè¡Œ
    DispatchQueue.main.asyncAfter(deadline: .now() + 4.0) {
        subjectL.send(6) // â† ãã®4ç§’å¾Œã«å®Ÿè¡Œ
    }
}

// å‡ºåŠ›
// receiveValue: 10
// finished â† first()ã®ãŠã‹ã’ã§ 4 ç§’å¾…ã¤ã“ã¨ã¯ãªã timeoutError ã«ãªã‚‰ãªã„
```

ã‚‚ã¡ã‚ã‚“ã€3 ç§’ä»¥å†…ã« nil ä»¥å¤–ã®å€¤ãŒã“ãªã‘ã‚Œã°ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã™â†“

```swift
subjectL.send(nil) // â† å³æ™‚å®Ÿè¡Œ
DispatchQueue.main.asyncAfter(deadline: .now() + 4.0) { // â† 4ç§’å¾…ãŸã›ã‚‹
    subjectL.send(5) // â† ãã®4ç§’å¾Œã«å®Ÿè¡Œ
    DispatchQueue.main.asyncAfter(deadline: .now() + 4.0) {
        subjectL.send(6) // â† ãã®4ç§’å¾Œã«å®Ÿè¡Œ
    }
}

// å‡ºåŠ›
// error: timeoutError
```

ä»¥ä¸Šã§ã™ã€‚

# ä¸Šè¨˜ã®ã‚µãƒ³ãƒ—ãƒ«å‡¦ç†ãŒã‚ˆãã‚ã‹ã‚‰ãªã„äººã¸â†“

ä»¥é™ã¯ã‚µãƒ³ãƒ—ãƒ«å‡¦ç†ã®è§£èª¬ã§ãªã„ã§ã™ãŒã€Combine ã®æŒ™å‹•ã®ãƒã‚¤ãƒ³ãƒˆã‚’æ›¸ãè¨˜ã—ãŸã‚‚ã®ã«ãªã‚Šã¾ã™ã€‚

## å‰æå‡¦ç†

ä»¥ä¸‹ã®å®šç¾©ã¯ã™ã¹ã¦ã«å…±é€šã—ã¾ã™ã€‚

```swift
import Combine
import Foundation

enum TestError: Error {
    case minusError
    case nilError
    case timeoutError
    case otherError
}

func twice(num: Int) -> Int {
    return num * 2
}

var cancellables = Set<AnyCancellable>()
```

- `TestError` ã¨ã„ã†é©å½“ãªã‚¨ãƒ©ãƒ¼ã‚’ç”¨æ„
- `twice(num: Int)` ã¨ã„ã†æ•°å€¤ã‚’ 2 å€ã™ã‚‹é©å½“ãªé–¢æ•°ã‚’ç”¨æ„
- `cancellables` ã¨ã„ã†é©å½“ãª `AnyCancellable` ã‚’ `.store(in: &cancellables)` ã§ãã‚‹å¤‰æ•°ã‚’ç”¨æ„


## ãŠæ–­ã‚Š

æ‰€ã€…ã§ `nil` ã‚’è¿”å´ã—ãªã„å‡¦ç†ã§ã€`compactMap()` ã‚’ä½¿ç”¨ã—ã¦ã—ã¾ã£ã¦ãŠã‚Šã¾ã™ãŒã€èª¤ã£ãŸä½¿ã„æ–¹ã§ã™ã€‚
ãã†ã„ã†å ´åˆã¯ `map()` ã‚’ä½¿ã„ã¾ã—ã‚‡ã†ã€‚

ã¾ãŸã€`map()` ã§ `AnyPublisher<Output, Failure>` ã‚’è¿”ã™ã‚ˆã†ãªå ´åˆã¯ã€`map()` ã§ã¯ãªã `flatMap()` ã¨ã—ã¦ã‚ã’ãŸæ–¹ãŒè‰¯ã„ã§ã™ã€‚

ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚

## `CurrentValueSubject` ã®åˆæœŸåŒ–


```swift:å¤±æ•—ä¾‹
var subjectA: CurrentValueSubject<Int?, Never>

// CurrentValueSubject<Output, Failure> ã¯åˆæœŸåŒ–ãŒå¿…è¦
subject.value = 0 // â† ã„ããªã‚Šä»£å…¥ã™ã‚‹ã¨ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
```

```swift:æˆåŠŸä¾‹
var subjectA: CurrentValueSubject<Int?, Never>

subjectA = CurrentValueSubject<Int?, Never>(nil) // nilã§åˆæœŸåŒ–
subjectA.value = 1 // åˆæœŸåŒ–å¾Œãªã‚‰ã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã„
```

- `CurrentValueSubject<Output, Failure>` ã¯åˆæœŸåŒ–ãŒå¿…è¦


## `sink` ã®æŒ™å‹•


```swift
var subjectB = CurrentValueSubject<Int?, Never>(nil)
subjectB
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \(String(describing: $0))")
    }
    .store(in: &cancellables)

// å‡ºåŠ›â†“
// receiveValue: nil â† ã„ããªã‚Šnilã§ãªãŒã‚Œã‚‹
```

- `sink` ã™ã‚‹ã¨ã„ããªã‚Šå‡¦ç†ãŒæµã‚Œã‚‹ â†’ åˆæœŸå€¤ãŒæµã‚Œã‚‹


## `dropFirst` ã®æŒ™å‹•


```swift
var subjectC = CurrentValueSubject<Int?, Never>(nil)
subjectC
    .dropFirst() // â† è¿½åŠ 
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \(String(describing: $0))")
    }
    .store(in: &cancellables)

// å‡ºåŠ›â†“
// ãªã— â† .dropFirst()ã®ãŠã‹ã’ã§åˆå›ï¼ˆåˆæœŸå€¤ï¼‰ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯ãªãŒã‚Œãªã„
```

- `dropFirst` ã§åˆå›ï¼ˆåˆæœŸå€¤ï¼‰ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æµã‚Œã‚‹ã®ã‚’é˜²ã

## `send` ã®æŒ™å‹•


```swift
var subjectC = CurrentValueSubject<Int?, Never>(nil)
subjectC
    .dropFirst()
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \(String(describing: $0))")
    }
    .store(in: &cancellables)

/// sendã¾ãŸã¯valueã®ä»£å…¥ã«ã‚ˆã£ã¦ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒèµ°ã‚‹
subjectC.send(1)
subjectC.send(nil)
subjectC.send(2)
subjectC.value = 3

// å‡ºåŠ›â†“
// receiveValue: Optional(1)
// receiveValue: nil
// receiveValue: Optional(2)
// receiveValue: Optional(3)
```

- `send` ã¾ãŸã¯ `value` ã®ä»£å…¥ã«ã‚ˆã£ã¦ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒèµ°ã‚‹


## `cancel` ã®æŒ™å‹•


```swift
var subjectC = CurrentValueSubject<Int?, Never>(nil)
subjectC
    .dropFirst()
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \(String(describing: $0))")
    }
    .store(in: &cancellables)

/// cancel ã®å‡¦ç†ã®æŒ™å‹•
subjectC.send(1)
subjectC.send(nil)
cancellables.forEach{ $0.cancel() } // cancel()ã®å®Ÿæ–½
subjectC.send(2) // cancel()ä»¥é™å‡¦ç†ã—ãªããªã‚‹
subjectC.value = 3 // cancel()ä»¥é™å‡¦ç†ã—ãªããªã‚‹

// å‡ºåŠ›â†“
// receiveValue: Optional(1)
// receiveValue: nil
```

- `cancel` ä»¥é™ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯æµã‚Œãªã„


## `completion: .finished` ã®æŒ™å‹•


```swift
var subjectC = CurrentValueSubject<Int?, Never>(nil)
subjectC
    .dropFirst()
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \(String(describing: $0))")
    }
    .store(in: &cancellables)

subjectC.send(1)
subjectC.send(completion: .finished) // completion
subjectC.send(nil) // sinkã®completionã®å‡¦ç†ã«å…¥ã£ãŸãŸã‚sinkã¯èµ°ã‚‰ãªã„
subjectC.send(2) // sinkã®completionã®å‡¦ç†ã«å…¥ã£ãŸãŸã‚sinkã¯èµ°ã‚‰ãªã„
subjectC.value = 3 // sinkã®completionã®å‡¦ç†ã«å…¥ã£ãŸãŸã‚sinkã¯èµ°ã‚‰ãªã„

// å‡ºåŠ›â†“
// receiveValue: Optional(1)
// finished
```

- `completion` ã®å‡¦ç†ã«å…¥ã‚‹ã¨ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«å€¤ã¯èµ°ã‚‰ãªããªã‚‹


## `map` ã®æŒ™å‹•


```swift
var subjectD = CurrentValueSubject<Int?, Never>(nil)
subjectD
    .dropFirst()
    .map { twice(num: $0 ?? 0) } // â† è¿½åŠ 
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \(String(describing: $0))")
    }
    .store(in: &cancellables)

subjectD.send(1)
subjectD.send(nil)
subjectD.value = 2

// å‡ºåŠ›
// receiveValue: 2 â† map ã®å‡¦ç†ãŒé©å¿œ
// receiveValue: 0 â† nilã¯ $0 ?? 0 ã«ã‚ˆã£ã¦0ã«å¤‰æ›ã•ã‚Œã¦å‡¦ç†ã•ã‚ŒãŸ
// receiveValue: 4 â† map ã®å‡¦ç†ãŒé©å¿œ
```

- é…åˆ—æ“ä½œã® `map` ã¨ã»ã¼åŒã˜ã‚ˆã†ã«å‡¦ç†ã•ã‚Œã‚‹
- é–¢æ•°ã‚’é€šã—ã¦å€¤ã‚’å¤‰æ›ã•ã›ã‚‹ã®ã«ç›¸æ€§ãŒè‰¯ã„
- å ´åˆã«å¿œã˜ã¦å‹ã‚‚å¤‰ãˆã‚‹ã“ã¨ãŒã§ãã‚‹

## `compactMap` ã®æŒ™å‹•

```swift
var subjectE = CurrentValueSubject<Int?, Never>(nil)
subjectE
    .dropFirst()
    .compactMap { $0 } // â† è¿½åŠ 
    .map { twice(num: $0 )} // å…ˆã«compactMap()ã™ã‚‹ã“ã¨ã«ã‚ˆã£ã¦ã‚¢ãƒ³ãƒ©ãƒƒãƒ—å‡¦ç†ã‚’çœç•¥
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \(String(describing: $0))")
    }
    .store(in: &cancellables)

subjectE.send(1)
subjectE.send(nil) // â† compactMapã«ã‚ˆã‚Šnilã¯å‡ºåŠ›ãªã—
subjectE.value = 2

// å‡ºåŠ›
// receiveValue: 2 â† ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ãŒå¤–ã‚Œã‚‹
// receiveValue: 4 â† ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«ãŒå¤–ã‚Œã‚‹
```

- `compactMap()` ã¯ nil ã®éš›ã«å‡¦ç†ã‚’æµã‚Œãªãã™ã‚‹
- `compactMap { $0 }` ã¯ Combine ãªã‚‰ã§ã¯ã® `guard let hoge = hoge else { return }` ã®ã‚ˆã†ãªã‚¤ãƒ¡ãƒ¼ã‚¸

`compactMap { $0 }` ã¯æ›¸ãæ›ãˆã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã€‚

```swift
var subjectF = CurrentValueSubject<Int?, Never>(nil)
subjectF
    .dropFirst()
    .compactMap { num -> Int? in // â† compactMap { $0 } ã¨åŒç­‰ã®å‡¦ç†
        guard let num = num else {
            return nil
        }
        return num
    }
    .map { twice(num: $0) }
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \(String(describing: $0))")
    }
    .store(in: &cancellables)
```

## `Fail`ã€`Just`ã€`eraseToAnyPublisher`ã€`setFailureType`ã€`flatMap` ã®åˆã‚ã›æŠ€


```swift
var subjectG = CurrentValueSubject<Int?, Never>(nil)
subjectG
    .dropFirst()
    .flatMap { num -> AnyPublisher<Int, TestError> in // å‹ã‚’æŒ‡å®š
        guard let num = num else {
            return Fail(error: TestError.nilError) // Fail(error: Error)ã‚’è¿”ã™
                .eraseToAnyPublisher()
        }
        return Just(num)
            .setFailureType(to: TestError.self) // AnyPublisher<Int, TestError> ã«ã‚ã‚ã›ã‚‹
            .eraseToAnyPublisher()
    }
    .map { twice(num: $0) }
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \($0)")
    }
    .store(in: &cancellables)

subjectG.send(1)
subjectG.send(nil) // â†  nil ã®ãŸã‚ã€Fail(error: TestError.nilError) ç™ºç”Ÿ
subjectG.value = 2 // â† ä¸Šã®å‡¦ç†ã«ã‚ˆã‚Š sink ã® completion ãƒ–ãƒ­ãƒƒã‚¯ã«å…¥ã£ãŸãŸã‚å‡¦ç†ãŒèµ°ã‚‰ãªã„

// å‡ºåŠ›
// receiveValue: 2
// error: nilError
```

- `Fail` ã¯ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ Publisherï¼ˆ`struct Fail<Output, Failure> : Publisher where Failure : Error`ï¼‰
- `Just` ã¯ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã•ãªã„ Publisherï¼ˆ`struct Just<Output> : Publisher`ï¼‰
- `.setFailureType(to: Error.self)` ã«ã‚ˆã£ã¦ã€Publisher ã«ä»»æ„ã®ã‚¨ãƒ©ãƒ¼ã‚’ä»˜ä¸ã§ãã‚‹ â† ã“ã‚Œã‚’ã¤ã‹ã£ã¦ `Just` ã«ã‚¨ãƒ©ãƒ¼ã‚’ä»˜ä¸ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½
- `AnyPublisher<Output, Error>` ã®ã‚ˆã†ãª publisher ã‚’è¿”ã™å ´åˆã¯ `.eraseToAnyPublisher()` ã‚’ã¤ã‘ã¦ã‚ã’ã‚‹ã¨å‹ãŒæƒã†
- `flatMap()` ã¯ `AnyPublisher<Output, Failure>` ã‚’æµã™ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ä½œæˆã™ã‚‹ ï¼ˆã“ã“ã‚’ `map()` ã«ã™ã‚‹ã¨ `AnyPublisher<Output, Failure>` ã®å‹ã§ã‚ã£ã¦ã‚‚ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯æµã‚Œãªã„ï¼‰
- `Fail` ã‚’æ¤œçŸ¥ã™ã‚‹ã¨ `sink` ã® `completion` ãƒ–ãƒ­ãƒƒã‚¯ã«å…¥ã‚Šãã‚Œä»¥é™ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã«æµã‚Œã¦ããŸå€¤ã¯å‡¦ç†ã—ãªã„

## `errorMap` ã®æŒ™å‹•


```swift
var subjectH = CurrentValueSubject<Int?, Never>(nil)
subjectH
    .dropFirst()
    .compactMap { num -> AnyPublisher<Int, TestError> in // å‹ã‚’æŒ‡å®š
        guard let num = num else {
            return Fail(error: TestError.nilError) // Fail(error: Error)ã‚’è¿”ã™
                .eraseToAnyPublisher()
        }
        return Just(num)
            .setFailureType(to: TestError.self) // AnyPublisher<Int, TestError> ã«ã‚ã‚ã›ã‚‹
            .eraseToAnyPublisher()
    }
    .flatMap { $0 } // AnyPublisher<Int, TestError> ã‚’ Int ã¨ TestError ã«åˆ†ã‘ã‚‹
    .map { twice(num: $0) }
    .mapError { error -> TestError in
        print("before error: \(error)")
        return TestError.otherError // ã™ã¹ã¦TestError.otherErrorã«å¤‰æ›ã™ã‚‹
    }
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \($0)")
    }
    .store(in: &cancellables)

subjectH.send(1)
subjectH.send(nil) // â†  nil ã®ãŸã‚ã€Fail(error: TestError.nilError) ç™ºç”Ÿ
subjectH.value = 2 // â† ä¸Šã®å‡¦ç†ã«ã‚ˆã‚Š sink ã® completion ãƒ–ãƒ­ãƒƒã‚¯ã«å…¥ã£ãŸãŸã‚å‡¦ç†ãŒèµ°ã‚‰ãªã„

// å‡ºåŠ›
// receiveValue: 2
// before error: nilError
// error: otherError // â† nilError ã ã£ãŸã‚¨ãƒ©ãƒ¼ãŒ otherError ã«å¤‰æ›´ã•ã‚Œã¦ã„ã‚‹
```

- `map` ã¯ `Output` ã«å¯¾ã—ã¦ã®ã¿å‡¦ç†ã‚’ã—ãªã„ã—ã€`errorMap` ã¯ `Failure` ã«ã®ã¿å‡¦ç†ã‚’é©å¿œã™ã‚‹

## `first` ã®æŒ™å‹•


```swift
var subjectI = CurrentValueSubject<Int?, Never>(nil)
subjectI
    .dropFirst()
    .first() // â† è¿½åŠ 
    .compactMap { num -> AnyPublisher<Int, TestError> in
        guard let num = num else {
            return Fail(error: TestError.nilError)
                .eraseToAnyPublisher()
        }
        return Just(num)
            .setFailureType(to: TestError.self)
            .eraseToAnyPublisher()
    }
    .flatMap { $0 }
    .map { twice(num: $0) }
    .mapError { error -> TestError in
        print("before error: \(error)")
        return TestError.otherError // ã™ã¹ã¦TestError.otherErrorã«å¤‰æ›ã™ã‚‹
    }
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \($0)")
    }
    .store(in: &cancellables)

subjectI.send(1) // â† first()ã«ã‚ˆã£ã¦1ã¤ã®å‡¦ç†ãŒçµ‚äº†ã—ãŸã‚‰sinkã®completionãƒ–ãƒ­ãƒƒã‚¯ã«å…¥ã‚‹
subjectI.send(nil) // â† ã™ã§ã«sinkã®completionãƒ–ãƒ­ãƒƒã‚¯ã«å…¥ã£ã¦ã„ã‚‹ãŸã‚å‡¦ç†ãŒèµ°ã‚‰ãªã„
subjectI.value = 2 // â† ã™ã§ã«sinkã®completionãƒ–ãƒ­ãƒƒã‚¯ã«å…¥ã£ã¦ã„ã‚‹ãŸã‚å‡¦ç†ãŒèµ°ã‚‰ãªã„

// å‡ºåŠ›
// receiveValue: 2
```

- `first()` ã¯ã²ã¨ã¤ã®ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’å—ã‘å–ã£ãŸã‚‰ `completion` ã¨ãªã‚‹
- ã²ã¨ã¤ã‚ã§ `completion` ã™ã‚‹ã®ã§ã¯ãªãã€N å›ç›®ã§ `completion` ã™ã‚‹ã‹ã‚’ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã™ã‚‹ã«ã¯ `prefix()` ã‚’ç”¨ã„ã‚‹â†“

## ã€è£œè¶³ã€‘ `prefix` ã®æŒ™å‹•

```swift
var subjectI = CurrentValueSubject<Int?, Never>(nil)
subjectI
    .dropFirst()
    .prefix(2) // â† è¿½åŠ 
    .compactMap { num -> AnyPublisher<Int, TestError> in
        guard let num = num else {
            return Fail(error: TestError.nilError)
                .eraseToAnyPublisher()
        }
        return Just(num)
            .setFailureType(to: TestError.self)
            .eraseToAnyPublisher()
    }
    .flatMap { $0 }
    .map { twice(num: $0) }
    .mapError { error -> TestError in
        print("before error: \(error)")
        return TestError.otherError // ã™ã¹ã¦TestError.otherErrorã«å¤‰æ›ã™ã‚‹
    }
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \($0)")
    }
    .store(in: &cancellables)

subjectI.send(1) // 1ã¤ã‚
subjectI.send(2) // 2ã¤ã‚ â† prefix(2)ã«ã‚ˆã‚Šã“ã®æ™‚ç‚¹ã§completionã™ã‚‹
subjectI.value = 3 // 3ã¤ã‚ â† completionãƒ–ãƒ­ãƒƒã‚¯ã«å…¥ã£ãŸãŸã‚å‡¦ç†ã•ã‚Œãªã„

// å‡ºåŠ›
// receiveValue: 2
// receiveValue: 4
// finished
```

- `prefix()` ã§ã€å€¤ãŒæ¥ã¦ã‹ã‚‰ N å›ç›®ã§ `completion` ã™ã‚‹ã‹ã‚’ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã§ãã‚‹
- ã¤ã¾ã‚Šã€`first()` ã¨ `prefix(1)` ã¯åŒã˜æŒ™å‹•ï¼ˆã®ã¯ãšï¼‰

## `timeout` ã®æŒ™å‹•

### åŸºæœ¬å½¢

```swift
var subjectJ = CurrentValueSubject<Int?, Never>(nil)
subjectJ
    .dropFirst()
    .compactMap { num -> AnyPublisher<Int, TestError> in
        guard let num = num else {
            return Fail(error: TestError.nilError)
                .eraseToAnyPublisher()
        }
        return Just(num)
            .setFailureType(to: TestError.self)
            .eraseToAnyPublisher()
    }
    .flatMap { $0 }
    .map { twice(num: $0) }
    .timeout( // â† è¿½åŠ 
        .seconds(3),
        scheduler: DispatchQueue.main,
        options: nil,
        customError: { .timeoutError }
    )
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \($0)")
    }
    .store(in: &cancellables)

subjectJ.send(5) // â† å³æ™‚å®Ÿè¡Œ
DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
    subjectJ.send(6) // â† send(5)ã®2ç§’å¾Œã«å®Ÿè¡Œ
    DispatchQueue.main.asyncAfter(deadline: .now() + 4.0) {
        subjectJ.send(7) // â† send(6)ã®4ç§’å¾Œã«å®Ÿè¡Œ â† timeoutãŒ3ç§’ã®ãŸã‚å®Ÿè¡Œã•ã‚Œãªã„
    }
}


// å‡ºåŠ›
// receiveValue: 10
// receiveValue: 12 // â† subjectJ.send(5)å®Ÿè¡Œã‹ã‚‰2ç§’å¾Œ
// error: timeoutError // â† subjectJ.send(6)å®Ÿè¡Œã‹ã‚‰3ç§’å¾Œ
```

- `timeout()` ã§è¨­å®šã™ã‚‹æœŸé–“ã¯ã€å€¤ã‚’æœ€åˆã«å—ã‘å§‹ã‚ã¦ã‹ã‚‰ `completion` ã™ã‚‹ã¾ã§ã®æ™‚é–“ã§ã¯ãªãã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒæµã‚Œã¦ã„ãªã„æœŸé–“ã‚’æŒ‡å®šã—ãŸã“ã¨ã¨ãªã‚‹
- ä¸€åº¦ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã™ã‚‹ã¨ `completion` å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã‚‹ãŸã‚ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ã¯èµ°ã‚‰ãªããªã‚‹

### ã‚ã–ã¨ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã•ã›ã‚‹æ–¹æ³•

```swift
var subjectK = CurrentValueSubject<Int?, Never>(nil)
subjectK
    .compactMap { _ -> Int? in return nil } // â† ã‚ã–ã¨å…¨ã¦nilã«å¤‰æ›ã™ã‚‹
    .compactMap { num -> AnyPublisher<Int, TestError>? in
        guard num > 0 else {
            return Fail(error: TestError.minusError)
                .eraseToAnyPublisher()
        }
        return Just(num)
            .setFailureType(to: TestError.self)
            .eraseToAnyPublisher()
    }
    .flatMap { $0 }
    .map { twice(num: $0) }
    .timeout(
        .seconds(3),
        scheduler: DispatchQueue.main,
        options: nil,
        customError: { .timeoutError }
    )
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \($0)")
    }
    .store(in: &cancellables)

subjectK.send(7)

// å‡ºåŠ›
// error: timeoutError
```

- `.compactMap { _ -> Int? in return nil }` ã§ã€ã‚ã–ã¨å…¨ã¦ `nil` ã«å¤‰æ›ã™ã‚‹å‡¦ç†ã‚’ `compactMap()` å†…ã§è¡Œã†ã¨ã€ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒæµã‚Œãªã„ã®ã§ timeout ã™ã‚‹


## ã‚¿ã‚¤ãƒˆãƒ«å›å

åˆæœŸå€¤ãŒ nil ã® CurrentValueSubject ã«ã¤ã„ã¦ nil ä»¥å¤–ã®å€¤ãŒãã‚‹ã¾ã§ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®šã™ã‚‹

### ã†ã¾ãã„ãä¾‹

åˆæœŸå€¤ãŒ nil ã® CurrentValueSubject ãŒã‚ã‚‹ã¨ãã€nil ä»¥å¤–ã®æœ€åˆã®ä¸€ã¤ç›®ã®å€¤ãŒãã‚‹ã¾ã§ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®šã™ã‚‹ã«ã¯ã€ä»¥ä¸‹ã®é †ã§å‡¦ç†ã—ã¦ã‚ã’ã‚‹ã¨ã†ã¾ãã„ãã€‚

1. `compactMap()`
2. `first()`
3. `timeout()` 

```swift
var subjectL = CurrentValueSubject<Int?, Never>(nil)
subjectL
    .compactMap { $0 } // â† nilã‚’æ’é™¤
    .first() // â† nil ä»¥å¤–ã®å€¤ãŒãã‚Œã° completion ãŒå‘¼ã°ã‚Œã‚‹
    .setFailureType(to: TestError.self) // â† timeout ã® Failure ã‚’è¨­å®šã—ã¦ã‚ã’ã‚‹
    .timeout(
        .seconds(3),
        scheduler: DispatchQueue.main,
        options: nil,
        customError: { .timeoutError }
    )
    .compactMap { num -> AnyPublisher<Int, TestError> in
        guard num > 0 else {
            return Fail(error: TestError.minusError)
                .eraseToAnyPublisher()
        }
        return Just(num)
            .setFailureType(to: TestError.self)
            .eraseToAnyPublisher()
    }
    .flatMap { $0 }
    .map { twice(num: $0) }
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \($0)")
    }
    .store(in: &cancellables)

subjectL.send(nil) // â† å³æ™‚å®Ÿè¡Œ
DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
    subjectL.send(5) // â† ãã®2ç§’å¾Œã«å®Ÿè¡Œ
    DispatchQueue.main.asyncAfter(deadline: .now() + 4.0) {
        subjectL.send(6) // â† ãã®4ç§’å¾Œã«å®Ÿè¡Œ
    }
}

// å‡ºåŠ›
// receiveValue: 10
// finished â† first()ã®ãŠã‹ã’ã§ 4 ç§’å¾…ã¤ã“ã¨ã¯ãªã timeoutError ã«ãªã‚‰ãªã„
```

### ã†ã¾ãã„ã‹ãªã„ä¾‹1

`first()` ã‚’æŠœã„ã¦ã¿ãŸå ´åˆâ†“

```swift
var subjectL = CurrentValueSubject<Int?, Never>(nil)
subjectL
    .compactMap { $0 } // â† nilã‚’æ’é™¤
//    .first() // â† nil ä»¥å¤–ã®å€¤ãŒãã‚Œã° completion ãŒå‘¼ã°ã‚Œã‚‹
    .setFailureType(to: TestError.self) // â† timeout ã® Failure ã‚’è¨­å®šã—ã¦ã‚ã’ã‚‹
    .timeout(
        .seconds(3),
        scheduler: DispatchQueue.main,
        options: nil,
        customError: { .timeoutError }
    )
    .compactMap { num -> AnyPublisher<Int, TestError> in
        guard num > 0 else {
            return Fail(error: TestError.minusError)
                .eraseToAnyPublisher()
        }
        return Just(num)
            .setFailureType(to: TestError.self)
            .eraseToAnyPublisher()
    }
    .flatMap { $0 }
    .map { twice(num: $0) }
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \($0)")
    }
    .store(in: &cancellables)

subjectL.send(nil) // â† å³æ™‚å®Ÿè¡Œ
DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
    subjectL.send(5) // â† ãã®2ç§’å¾Œã«å®Ÿè¡Œ
    DispatchQueue.main.asyncAfter(deadline: .now() + 4.0) {
        subjectL.send(6) // â† ãã®4ç§’å¾Œã«å®Ÿè¡Œ
    }
}

// å‡ºåŠ›
// receiveValue: 10
// receiveValue: 12
// error: timeoutError
```

- `first()` ãŒãªã„ãŸã‚ã€æ˜ç¢ºã«ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’æ­¢ã‚ãªã„é™ã‚Š `completion` ã®ãƒ–ãƒ­ãƒƒã‚¯ã«ã¯è¡Œã‹ãªã„ãŸã‚ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚¨ãƒ©ãƒ¼ã¨ãªã‚‹

### ã†ã¾ãã„ã‹ãªã„ä¾‹2

`first()` ã®ã‚ã¨ã« `compactMap()` ã—ãŸå ´åˆâ†“

```swift
var subjectL = CurrentValueSubject<Int?, Never>(nil)
subjectL
    .dropFirst()
    .first() // â† å€¤ãŒãã‚Œã° completion ãŒå‘¼ã°ã‚Œã‚‹
    .compactMap { $0 } // â† nilã‚’æ’é™¤
    .setFailureType(to: TestError.self) // â† timeout ã® Failure ã‚’è¨­å®šã—ã¦ã‚ã’ã‚‹
    .timeout(
        .seconds(3),
        scheduler: DispatchQueue.main,
        options: nil,
        customError: { .timeoutError }
    )
    .compactMap { num -> AnyPublisher<Int, TestError> in
        guard num > 0 else {
            return Fail(error: TestError.minusError)
                .eraseToAnyPublisher()
        }
        return Just(num)
            .setFailureType(to: TestError.self)
            .eraseToAnyPublisher()
    }
    .flatMap { $0 }
    .map { twice(num: $0) }
    .sink { completion in
        switch completion {
        case .finished:
            print("finished")
        case let .failure(error):
            print("error: \(error)")
        }
    } receiveValue: {
        print("receiveValue: \($0)")
    }
    .store(in: &cancellables)

subjectL.send(nil) // â† å³æ™‚å®Ÿè¡Œ
DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
    subjectL.send(5) // â† ãã®2ç§’å¾Œã«å®Ÿè¡Œ
    DispatchQueue.main.asyncAfter(deadline: .now() + 4.0) {
        subjectL.send(6) // â† ãã®4ç§’å¾Œã«å®Ÿè¡Œ
    }
}

// å‡ºåŠ›
// finished
```

- `subjectL.send(nil)` ã§ nil ãŒæ¥ã¦ã€`first()` ã‚’é€šéã™ã‚‹ã®ã§ã€ãã®æ™‚ç‚¹ã§ `completion` ã™ã‚‹ã“ã¨ãŒç¢ºå®šã—ã€`compactMap { $0 }` ã§ nil ãŒæ’é™¤ã•ã‚Œã¦ã™ãã« `completion` ã®ãƒ–ãƒ­ãƒƒã‚¯ã«å…¥ã‚‹

