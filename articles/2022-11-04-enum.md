---
title: "[Swift] ÈÄ£ÊÉ≥ÂÄ§„ÇíÊåÅ„Å§ enum „Å´ Equatable „ÇíÈÅ©Âøú„Åï„Åõ„ÅüÂ†¥Âêà„ÅÆÊåôÂãï"
emoji: "üïä"
type: "tech" # tech: ÊäÄË°ìË®ò‰∫ã / idea: „Ç¢„Ç§„Éá„Ç¢
topics: ["Swift"]
published: true
---

# ‰ºù„Åà„Åü„ÅÑ„Åì„Å®

- ÈÄ£ÊÉ≥ÂÄ§(Associated value)„ÇíÊåÅ„Å§ enum „Åß„ÇÇ `Equatable` „Å´Ê∫ñÊã†„Åï„Åõ„Çã„Å†„Åë„Åß `==` ÊºîÁÆóÂ≠ê„ÅßÊØîËºÉ„ÅåÂèØËÉΩ
- ÈÄ£ÊÉ≥ÂÄ§„Åå„Åù„ÇÇ„Åù„ÇÇ `Equatable` „Å´Ê∫ñÊã†„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅÈÄ£ÊÉ≥ÂÄ§„ÅÆÊñπ„Çí `Equatable` „Å´Ê∫ñÊã†„Åï„Åõ„Çã„Å®„Ç∑„É≥„Éó„É´„Å´Ë®òËø∞„Åß„Åç„Çã
- ÈÄöÂ∏∏„Å®Áï∞„Å™„Çã `==` ÊºîÁÆóÂ≠ê„Çí‰ΩøÁî®„Åô„Çã„ÅÆ„ÅØÊéß„Åà„Å¶„ÄÅ„Åù„ÅÆ‰ª£„Çè„Çä„Å´Èñ¢Êï∞„ÇíÁî®ÊÑè„Åô„Çã„ÅÆ„ÅåË¶™Âàá

# „Çµ„É≥„Éó„É´„Ç≥„Éº„Éâ

ÈÄ£ÊÉ≥ÂÄ§(Associated value)„ÇíÊåÅ„Å§ enum „Åß„ÇÇ `Equatable` „Å´Ê∫ñÊã†„Åï„Åõ„Çã„Å†„Åë„Åß„ÄÅ`==` ÊºîÁÆóÂ≠ê„Åß„ÅÆÊØîËºÉ„ÅåÂèØËÉΩ„Åø„Åü„ÅÑ„Åß„Åô„ÄÇ

„Å§„Åæ„Çã„Å®„Åì„Çç„ÄÅ`func ==(lhs: Self, rhs: Self) -> Bool` „ÅÆÂÆöÁæ©„ÅØ‰∏çË¶Å„ÅÆ„Çà„ÅÜ„Åß„Åô„ÄÇ

```swift
enum Hoge: Equatable {
    case moge
    case piyo(Int)
}

let hoge1: Hoge = .moge
let hoge2: Hoge = .piyo(2)
let hoge3: Hoge = .piyo(3)
let hoge4: Hoge = .piyo(2)

print(hoge1 == hoge2) // false
print(hoge2 == hoge3) // false
print(hoge2 == hoge4) // true
```

# ÔºàÁï™Â§ñÁ∑®„Åù„ÅÆ1ÔºâÈÄ£ÊÉ≥ÂÄ§„Åå Equatable „Å´ÈÅ©ÂøúÊ∫ñÊã†„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà

ÈÄ£ÊÉ≥ÂÄ§„Åå Equatable „Å´ÈÅ©ÂøúÊ∫ñÊã†„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅenum „Å´ `Equatable` „Å´Ê∫ñÊã†„Åï„Åõ„Çã„Å†„Åë„Åß„ÅØ„ÄÅ`==` ÊºîÁÆóÂ≠ê„Åå‰ΩøÁî®„Åß„Åç„Åæ„Åõ„Çì„ÄÇ

„Åù„ÅÆ„Åü„ÇÅ„ÄÅ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´„ÄÅ`func ==(lhs: Self, rhs: Self) -> Bool` „ÅÆÂÆöÁæ©„ÅåÂøÖË¶Å„Å´„Å™„Çä„Åæ„Åô„ÄÇ

```swift
struct Fuga {
    var fugafuga: Int
}

enum Hoge {
    case moge
    case piyo(Fuga)
}

extension Hoge: Equatable {
    static func == (lhs: Hoge, rhs: Hoge) -> Bool {
        switch (lhs, rhs) {
        case (.moge, .moge):
            return true
        case (.moge, .piyo(_)):
            return false
        case (.piyo(_), .moge):
            return false
        case (.piyo(let lhsFuga), .piyo(let rhsFuga)):
            return lhsFuga.fugafuga == rhsFuga.fugafuga
        }
    }
}

let hoge1: Hoge = .moge
let hoge2: Hoge = .piyo(.init(fugafuga: 2))
let hoge3: Hoge = .piyo(.init(fugafuga: 3))
let hoge4: Hoge = .piyo(.init(fugafuga: 2))

print(hoge1 == hoge2) // false
print(hoge2 == hoge3) // false
print(hoge2 == hoge4) // true
```

„ÅÑ„ÇÑ„Å†„Å£„Åü„Çâ„ÄÅ`Fuga` „Å´ `Equatable` „ÇíÊ∫ñÊã†„Åï„Åõ„Çå„Å∞ËâØ„ÅÑ„ÅÆ„Åß„ÅØÔºü„Å®„Å™„Çä„Åæ„Åô„Åå„ÄÅ„Åù„ÅÆÈÄö„Çä„Å†„Å®ÊÄù„ÅÑ„Åæ„Åô„ÄÇ

‰ª•‰∏ã„ÄÅ„Çµ„É≥„Éó„É´„Ç≥„Éº„Éâ„Å´„Å™„Çä„Åæ„Åô„ÄÇ

```swift
struct Fuga: Equatable {
    var fugafuga: Int
}

enum Hoge: Equatable {
    case moge
    case piyo(Fuga)
}

let hoge1: Hoge = .moge
let hoge2: Hoge = .piyo(.init(fugafuga: 2))
let hoge3: Hoge = .piyo(.init(fugafuga: 3))
let hoge4: Hoge = .piyo(.init(fugafuga: 2))

print(hoge1 == hoge2) // false
print(hoge2 == hoge3) // false
print(hoge2 == hoge4) // true
```

„ÅØ„Çã„Åã„Å´„Ç∑„É≥„Éó„É´„Åß„Åô„Å≠„ÄÇ

‰∏äË®ò„ÅßÂïèÈ°å„Å™„ÅÑ„Ç±„Éº„Çπ„Åß„ÅÇ„Çå„Å∞„ÄÅÈÄ£ÊÉ≥ÂÄ§„Åå„Åù„ÇÇ„Åù„ÇÇ `Equatable` „Å´Ê∫ñÊã†„Åó„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅØ„ÄÅÈÄ£ÊÉ≥ÂÄ§„ÅÆÊñπ„Çí `Equatable` „Å´Ê∫ñÊã†„Åï„Åõ„Çã„Å®„Ç∑„É≥„Éó„É´„Å´Ë®òËø∞„Åß„Åç„Åù„ÅÜ„Åß„Åô„ÄÇ

# ÔºàÁï™Â§ñÁ∑®„Åù„ÅÆ2ÔºâÈÄ£ÊÉ≥ÂÄ§„ÇíÁÑ°Ë¶ñ„Åó„Å¶ÂàóÊåô„Åó„Åü enum „Åå„ÅÇ„Å£„Å¶„Çå„Å∞ true „ÇíËøî„Åó„Å¶„Åª„Åó„ÅÑ„Å®„Åç

ÈÄ£ÊÉ≥ÂÄ§„ÇíÁÑ°Ë¶ñ„Åó„Å¶ÂàóÊåô„Åó„Åü enum „Åå„ÅÇ„Å£„Å¶„Çå„Å∞ true „ÇíËøî„Åó„Å¶„Åª„Åó„ÅÑ„Å®„Åç„ÇÇ„ÅÇ„Çã„Å®ÊÄù„ÅÑ„Åæ„Åô„ÄÇ

„Åù„ÅÜ„ÅÑ„ÅÜ„Å®„Åç„ÅØ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´Ëá™ÂàÜ„ÅßÂÆöÁæ©„Åó„Åæ„Åó„Çá„ÅÜ„ÄÇ

```swift
enum Hoge {
    case moge
    case piyo(Int)
}

extension Hoge: Equatable {
    static func == (lhs: Hoge, rhs: Hoge) -> Bool {
        switch (lhs, rhs) {
        case (.moge, .moge):
            return true
        case (.moge, .piyo(_)):
            return false
        case (.piyo(_), .moge):
            return false
        case (.piyo(_), .piyo(_)):
            return true
        }
    }
}

let hoge1: Hoge = .moge
let hoge2: Hoge = .piyo(2)
let hoge3: Hoge = .piyo(3)
let hoge4: Hoge = .piyo(2)

print(hoge1 == hoge2) // false
print(hoge2 == hoge3) // true
print(hoge2 == hoge4) // true
```

‰∏äË®ò„ÅÆÊõ∏„ÅçÊñπ„Å†„Å®Ê≠£Áõ¥„ÄÅÊôÆÈÄö„ÅÆ `==` ÊºîÁÆóÂ≠ê„Å®ÊåôÂãï„ÅåÁï∞„Å™„Å£„Å¶„ÄÅÊ∑∑‰π±„Åó„Å¶„Åó„Åæ„ÅÜÊÅê„Çå„Åå„ÅÇ„Çä„Åæ„Åô„ÄÇ

ÂÄã‰∫∫ÁöÑ„Å´„ÅØ„ÄÅ„Åù„ÅÆ„Çà„ÅÜ„Å™Âà§ÂÆö„Çí„Åó„Åü„ÅÑÂ†¥Âêà„ÅØ `==` „Çí„Ç™„Éº„Éê„Éº„É©„Ç§„Éâ„Åô„Çã„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅ‰ª•‰∏ã„ÅÆ„Çà„ÅÜ„Å´Èñ¢Êï∞„ÇíÁî®ÊÑè„Åó„Å¶„ÅÇ„Åí„ÅüÊñπ„Åå„ÄÅÂÑ™„Åó„ÅÑ„Ç≥„Éº„Éâ„Å™Ê∞ó„Åå„Åó„Åæ„Åô„ÄÇ

```swift
enum Hoge: Equatable {
    case moge
    case piyo(Int)
}

extension Hoge {
    func lazyEqual(_ rhs:Hoge) -> Bool {
        switch (self, rhs) {
        case (.moge, .moge):
            return true
        case (.moge, .piyo(_)):
            return false
        case (.piyo(_), .moge):
            return false
        case (.piyo(_), .piyo(_)):
            return true
        }
    }
}

let hoge1: Hoge = .moge
let hoge2: Hoge = .piyo(2)
let hoge3: Hoge = .piyo(3)
let hoge4: Hoge = .piyo(2)

print(hoge1 == hoge2) // false
print(hoge2 == hoge3) // false
print(hoge2 == hoge4) // true

print(hoge1.lazyEqual(hoge2)) // false
print(hoge2.lazyEqual(hoge3)) // true
print(hoge2.lazyEqual(hoge4)) // true
```

‰ª•‰∏ä„Å´„Å™„Çä„Åæ„Åô„ÄÇ