---
title: "[Swift] JSONSerialization ã‚’ä½¿ã£ã¦è¾æ›¸å‹ã«å¤‰æ›ã™ã‚‹ã¨æ•°å€¤ã‚„Boolå€¤ã®å‹ãŒå¤±ã‚ã‚Œã¦ã—ã¾ã†ä»¶"
emoji: "ğŸ˜„"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Swift"]
published: true
---

ç’°å¢ƒ: Xcode 14.2

## Struct â†’ Dictionary ã®å¤‰æ›ã®è¨˜è¿°

```swift
extension Encodable {
    func asDictionary(keyEncodingStrategy: JSONEncoder.KeyEncodingStrategy) throws -> [String: Any] {
        let encoder = JSONEncoder()
        encoder.keyEncodingStrategy = keyEncodingStrategy

        do {
            let data = try encoder.encode(self)
            guard let jsonObject = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] else {
                throw EncodingError.invalidValue(self, EncodingError.Context(codingPath: [], debugDescription: "Couldn't convert to [String: Any] dictionary"))
            }
            return jsonObject
        } catch {
            throw error
        }
    }
}
```

## Dictionary -> Struct ã®å¤‰æ›ã®è¨˜è¿°

```swift
extension Decodable {
    init(from dictionary: [String: Any], keyDecodingStrategy: JSONDecoder.KeyDecodingStrategy) throws {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = keyDecodingStrategy

        let data = try JSONSerialization.data(withJSONObject: dictionary, options: [])
        let decodedObject = try decoder.decode(Self.self, from: data)
        self = decodedObject
    }
}
```

## ã‚µãƒ³ãƒ—ãƒ«ã®å®šç¾©

```swift
struct Sample: Codable {
    let sampleInt: Int
    let sampleString: String
    let sampleDouble: Double
    let sampleFloat: Float
    let sampleBool: Bool
    let sampleDate: Date
    let sampleStruct: SampleStruct
    let sampleEnum: SampleEnum
}

struct SampleStruct: Codable {
    let hogeProperty: Int
}

enum SampleEnum: Codable {
    case hogeCase
}
```

## Struct -> Dictionary ã®å¤‰æ›

```swift
let sample = Sample(sampleInt: 1, sampleString: "a", sampleDouble: 2.0, sampleFloat: 3.0, sampleBool: true, sampleDate: Date(), sampleStruct: SampleStruct(hogeProperty: 4), sampleEnum: .hogeCase)

do {
    let dict1 = try sample.asDictionary(keyEncodingStrategy: .useDefaultKeys)
    let dict2 = try sample.asDictionary(keyEncodingStrategy: .convertToSnakeCase)
    print(dict1)
    print(dict2)
} catch {
    print("\(error)")
}
```

## .useDefaultKeys ã§å¤‰æ›ã—ãŸ Dictionary

```swift:dict1
[
    "sampleInt": 1,
    "sampleString": "a",
    "sampleDouble": 2, // Double(2.0) ãŒå‹æ‰‹ã« Int(2) ã«ä¸¸ã‚è¾¼ã¾ã‚Œã‚‹
    "sampleFloat": 3, // Double(3.0) ãŒå‹æ‰‹ã« Int(3) ã«ä¸¸ã‚è¾¼ã¾ã‚Œã‚‹
    "sampleBool": 1, // Bool(true) ãŒå‹æ‰‹ã« Int(1) ã«ä¸¸ã‚è¾¼ã¾ã‚Œã‚‹
    "sampleDate": 713534174.328627,
    "sampleStruct": [
        "hogeProperty": 4
    ],
    "sampleEnum": [
        "hogeCase": {}
    ]
]
```

## .convertToSnakeCase ã§å¤‰æ›ã—ãŸ Dictionary

```swift:dict2
[
    "sample_int": 1,
    "sample_string": "a",
    "sample_double": 2, // Double(2.0) ãŒå‹æ‰‹ã« Int(2) ã«ä¸¸ã‚è¾¼ã¾ã‚Œã‚‹
    "sample_float": 3, // Double(3.0) ãŒå‹æ‰‹ã« Int(3) ã«ä¸¸ã‚è¾¼ã¾ã‚Œã‚‹
    "sample_bool": 1, // Bool(true) ãŒå‹æ‰‹ã« Int(1) ã«ä¸¸ã‚è¾¼ã¾ã‚Œã‚‹
    "sample_date": 713534174.328627,
    "sample_struct": [
        "hoge_property": 4
    ],
    "sample_enum": [
        "hoge_case": {}
    ]
]
```

## Dictionary -> Struct ã®å¤‰æ›

```swift
let sample = Sample(sampleInt: 1, sampleString: "a", sampleDouble: 2.0, sampleFloat: 3.0, sampleBool: true, sampleDate: Date(), sampleStruct: SampleStruct(hogeProperty: 4), sampleEnum: .hogeCase)

do {
    let dict1 = try sample.asDictionary(keyEncodingStrategy: .useDefaultKeys)
    let dict2 = try sample.asDictionary(keyEncodingStrategy: .convertToSnakeCase)

    // ä»¥ä¸‹ã¯ã©ã¡ã‚‰ã‚‚åŒã˜å‡ºåŠ›ã«ãªã‚‹ï¼ˆ Encodable & Decodable ã® Struct -> Dictionary -> Struct ã®å¤‰æ›ãŒã†ã¾ãã„ã£ã¦ã„ã‚‹ï¼‰
    print(try Sample(from: dict1, keyDecodingStrategy: .useDefaultKeys))
    print(try Sample(from: dict2, keyDecodingStrategy: .convertFromSnakeCase))
} catch {
    print("\(error)")
}
```

## Dictionary -> Struct ã®å¤‰æ›ï¼ˆã‚¨ãƒ©ãƒ¼ã®æ¤œè¨¼ï¼‰

```swift
let sample = Sample(sampleInt: 1, sampleString: "a", sampleDouble: 2.0, sampleFloat: 3.0, sampleBool: true, sampleDate: Date(), sampleStruct: SampleStruct(hogeProperty: 4), sampleEnum: .hogeCase)

do {
    let dict1 = try sample.asDictionary(keyEncodingStrategy: .useDefaultKeys)
    let dict2 = try sample.asDictionary(keyEncodingStrategy: .convertToSnakeCase)

    // ã‚ã–ã¨ã€asDictionary ã§æŒ‡å®šã—ãŸ KeyDecodingStrategy ã¨ç•°ãªã‚‹å€¤ã‚’æŒ‡å®šã—ã¦ã¿ã‚‹
    print(try Sample(from: dict1, keyDecodingStrategy: .convertFromSnakeCase)) // â† ãªãœã‹ã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã„
    print(try Sample(from: dict2, keyDecodingStrategy: .useDefaultKeys)) // â† ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
} catch {
    print("\(error)")
}
```

## Codable ã‚„ JSONSerialization ã‚’ä½¿ã‚ãªã„ã§ Dictionary ã«ã™ã‚‹æ–¹æ³•

```swift
public enum CaseFormat {
    case original
    case snakeCase
}

public protocol ConvertibleToDictionary {
    func asDictionary(caseFormat: CaseFormat) -> [String: Any]
}

public extension ConvertibleToDictionary {
    func asDictionary(caseFormat: CaseFormat = .original) -> [String: Any] {
        let mirror = Mirror(reflecting: self)
        var dictionary: [String: Any] = [:]

        mirror.children.forEach { child in
            guard let keyName = child.label else { return }

            switch caseFormat {
            case .original:
                dictionary[keyName] = child.value
            case .snakeCase:
                dictionary[keyName.toSnakeCase] = child.value
            }
        }

        return dictionary
    }
}

extension String {
    var toSnakeCase: String {
        let snakeCased = unicodeScalars.reduce("") { result, scalar in
            if CharacterSet.uppercaseLetters.contains(scalar) {
                return "\(result)_\(Character(scalar))"
            } else {
                return result + String(scalar)
            }
        }.lowercased()

        if snakeCased.hasPrefix("_") {
            return String(snakeCased.dropFirst())
        } else {
            return snakeCased
        }
    }
}

let sample = Sample(sampleInt: 1, sampleString: "a", sampleDouble: 2.0, sampleFloat: 3.0, sampleBool: true, sampleDate: Date(), sampleStruct: SampleStruct(hogeProperty: 4), sampleEnum: .hogeCase)

let dict1 = sample.asDictionary(caseFormat: .original)
let dict2 = sample.asDictionary(caseFormat: .snakeCase)

print(dict1)
print(dict2)
```

## .original ã§å¤‰æ›ã—ãŸ Dictionary

```swift:dict1
[
    "sampleInt": 1,
    "sampleString": "a",
    "sampleDouble": 2.0,
    "sampleFloat": 3.0,
    "sampleBool": true,
    "sampleDate": "2023-08-12 12:48:45 +0000",
    "sampleStruct": "SampleStruct(hogeProperty: 4)",
    "sampleEnum": "SampleEnum.hogeCase"
]
```

## .snakeCase ã§å¤‰æ›ã—ãŸ Dictionary

```swift:dict2
[
    "sample_int": 1,
    "sample_string": "a",
    "sample_double": 2.0,
    "sample_float": 3.0,
    "sample_bool": true,
    "sample_date": "2023-08-12 12:48:45 +0000",
    "sample_struct": "SampleStruct(hogeProperty: 4)",
    "sample_enum": "SampleEnum.hogeCase"
]
```

## ãã‚‚ãã‚‚ãªãœã“ã®ã‚ˆã†ãªã“ã¨ã‚’ã‚„ã‚ŠãŸã„ã®ã‹ï¼Ÿ

Protocol Buffers ã® `google.protobuf.Value` ã§æ‰±ãˆã‚‹å‹ ã¯ `NullValue`, `double`, `string`, `bool`, `Struct`, `ListValue` ã®ã¿ã§ã€`map<string, google.protobuf.Value>` ã« Swift ã® Struct ã‚’è¾æ›¸å‹ã«å¤‰æ›ã™ã‚‹ã¨ãã«ä½¿ã†ã“ã¨ãŒç›®çš„ã§ã—ãŸã€‚

- https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/struct.proto#L62

ãã—ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ãªå‡¦ç†ã‚’æ›¸ãéš›ã« `JSONSerialization` ã‚’ä½¿ã†ã¨å‹æƒ…å ±ãŒå¤±ã‚ã‚Œã¦ã„ã‚‹ã®ã§ã€æ€ã£ãŸã‚ˆã†ãªå¤‰æ›ã‚’ã—ã¦ãã‚Œãªã„ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

```swift
import Foundation
import SwiftProtobuf

var toProtoBufValueDictionary: [String: Google_Protobuf_Value] {
    asDictionary(caseFormat: .snakeCase).mapValues { value in
        var protoValue = Google_Protobuf_Value()
        switch value {
        case let intValue as Int:
            protoValue.numberValue = Double(intValue)
        case let doubleValue as Double:
            protoValue.numberValue = doubleValue
        case let floatValue as Float:
            protoValue.numberValue = Double(floatValue)
        case let stringValue as String:
            protoValue.stringValue = stringValue
        case let dateValue as Date:
            protoValue.stringValue = ISO8601DateFormatter.sharedWithFractionalSeconds.string(from: dateValue)
        case let boolValue as Bool:
            protoValue.boolValue = boolValue
        default:
            assertionFailure("Unexpected type encountered while converting to Google_Protobuf_Value")
        }
        return protoValue
    }
}

extension ISO8601DateFormatter {
    static let sharedWithFractionalSeconds: ISO8601DateFormatter = {
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        formatter.timeZone = TimeZone.current
        return formatter
    }()
}
```