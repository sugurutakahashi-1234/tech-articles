---
title: "[Swift] JSONSerialization ã‚’ä½¿ã£ã¦è¾æ›¸å‹ã«å¤‰æ›ã™ã‚‹ã¨æ•°å€¤ã‚„ Bool å€¤ã®å‹ãŒå‹æ‰‹ã«å¤‰æ›´ã•ã‚Œã¦ã—ã¾ã†ä»¶"
emoji: "ğŸ•Š"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Swift"]
published: true
---

ç’°å¢ƒ: Xcode 14.2

# JSONSerialization ã«ã‚ˆã‚‹å‹ã®å¤‰åŒ–ã«ã¤ã„ã¦

Swift ã«ãŠã‘ã‚‹ `JSONSerialization` ã®æŒ™å‹•ã¯ã€ç‰¹å®šã®ã‚·ãƒŠãƒªã‚ªã§å¤‰æ•°ã®å‹ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚å…·ä½“çš„ã«ã¯ã€`Double` ã‚„` Float` ã®å°æ•°éƒ¨ãŒ `.0` ã®å ´åˆã€ãã‚Œã¯æ•´æ•°ã¨ã—ã¦ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã•ã‚Œã¾ã™ã€‚ã¾ãŸã€Boolã¯ `1`ï¼ˆ`true`ï¼‰ã¾ãŸã¯ `0`ï¼ˆ`false`ï¼‰ã¨ã—ã¦ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

## ãªãœã“ã®ã‚ˆã†ãªæŒ™å‹•ãŒç™ºç”Ÿã™ã‚‹ã®ã‹

JSON ã¯ã€Swift ã¨ã¯ç•°ãªã‚Šã€é™çš„å‹ä»˜ã‘ã‚’æŒãŸãªã„ãƒ‡ãƒ¼ã‚¿å½¢å¼ã§ã™ã€‚ã“ã®ãŸã‚ã€`JSONSerialization` ã¯ãƒ‡ãƒ¼ã‚¿ã‚’æœ€ã‚‚ã‚·ãƒ³ãƒ—ãƒ«ãªå½¢å¼ã«å¤‰æ›ã—ã‚ˆã†ã¨ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€`2.0` ã¯ `2` ã¨ã—ã¦ã€`true` ã¯ `1` ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã¾ã™ã€‚

## è§£æ±ºç­–

`JSONSerialization` ã®ä»£ã‚ã‚Šã«ã€ç›´æ¥è¾æ›¸ã¸ã®å¤‰æ›ã‚’è¡Œã†æ–¹æ³•ã‚’æ¡ç”¨ã™ã‚‹ã“ã¨ã§ã€å‹ã®å¤‰æ›´å•é¡Œã‚’å›é¿ã§ãã¾ã™ã€‚ã“ã®è¨˜äº‹ã§ã¯ã€`Mirror` ã‚’ä½¿ã£ãŸæ–¹æ³•ã‚’ç´¹ä»‹ã—ã¦ã„ã¾ã™ã€‚

## Struct â†’ Dictionary ã®å¤‰æ›ã®è¨˜è¿°

```swift
extension Encodable {
    func asDictionary(keyEncodingStrategy: JSONEncoder.KeyEncodingStrategy) throws -> [String: Any] {
        let encoder = JSONEncoder()
        encoder.keyEncodingStrategy = keyEncodingStrategy

        do {
            let data = try encoder.encode(self)
            guard let jsonObject = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] else {
                throw EncodingError.invalidValue(self, EncodingError.Context(codingPath: [], debugDescription: "Couldn't convert to [String: Any] dictionary"))
            }
            return jsonObject
        } catch {
            throw error
        }
    }
}
```

## Dictionary -> Struct ã®å¤‰æ›ã®è¨˜è¿°

```swift
extension Decodable {
    init(from dictionary: [String: Any], keyDecodingStrategy: JSONDecoder.KeyDecodingStrategy) throws {
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = keyDecodingStrategy

        let data = try JSONSerialization.data(withJSONObject: dictionary, options: [])
        let decodedObject = try decoder.decode(Self.self, from: data)
        self = decodedObject
    }
}
```

## ã‚µãƒ³ãƒ—ãƒ«ã®å®šç¾©

```swift
struct Sample: Codable {
    let sampleInt: Int
    let sampleString: String
    let sampleDouble: Double
    let sampleFloat: Float
    let sampleBool: Bool
    let sampleDate: Date
    let sampleStruct: SampleStruct
    let sampleEnum: SampleEnum
}

struct SampleStruct: Codable {
    let hogeProperty: Int
}

enum SampleEnum: Codable {
    case hogeCase
}
```

## Struct -> Dictionary ã®å¤‰æ›

```swift
let sample = Sample(sampleInt: 1, sampleString: "a", sampleDouble: 2.0, sampleFloat: 3.0, sampleBool: true, sampleDate: Date(), sampleStruct: SampleStruct(hogeProperty: 4), sampleEnum: .hogeCase)

do {
    let dict1 = try sample.asDictionary(keyEncodingStrategy: .useDefaultKeys)
    let dict2 = try sample.asDictionary(keyEncodingStrategy: .convertToSnakeCase)
    print(dict1)
    print(dict2)
} catch {
    print("\(error)")
}
```

## .useDefaultKeys ã§å¤‰æ›ã—ãŸ Dictionary ã®å‡ºåŠ›

```swift:dict1
[
    "sampleInt": 1,
    "sampleString": "a",
    "sampleDouble": 2, // Double(2.0) ãŒå‹æ‰‹ã« Int(2) ã«ä¸¸ã‚è¾¼ã¾ã‚Œã‚‹
    "sampleFloat": 3, // Double(3.0) ãŒå‹æ‰‹ã« Int(3) ã«ä¸¸ã‚è¾¼ã¾ã‚Œã‚‹
    "sampleBool": 1, // Bool(true) ãŒå‹æ‰‹ã« Int(1) ã«ä¸¸ã‚è¾¼ã¾ã‚Œã‚‹
    "sampleDate": 713534174.328627,
    "sampleStruct": [
        "hogeProperty": 4
    ],
    "sampleEnum": [
        "hogeCase": {}
    ]
]
```

## .convertToSnakeCase ã§å¤‰æ›ã—ãŸ Dictionary ã®å‡ºåŠ›

```swift:dict2
[
    "sample_int": 1,
    "sample_string": "a",
    "sample_double": 2, // Double(2.0) ãŒå‹æ‰‹ã« Int(2) ã«ä¸¸ã‚è¾¼ã¾ã‚Œã‚‹
    "sample_float": 3, // Double(3.0) ãŒå‹æ‰‹ã« Int(3) ã«ä¸¸ã‚è¾¼ã¾ã‚Œã‚‹
    "sample_bool": 1, // Bool(true) ãŒå‹æ‰‹ã« Int(1) ã«ä¸¸ã‚è¾¼ã¾ã‚Œã‚‹
    "sample_date": 713534174.328627,
    "sample_struct": [
        "hoge_property": 4
    ],
    "sample_enum": [
        "hoge_case": {}
    ]
]
```

## Dictionary -> Struct ã®å¤‰æ›

```swift
let sample = Sample(sampleInt: 1, sampleString: "a", sampleDouble: 2.0, sampleFloat: 3.0, sampleBool: true, sampleDate: Date(), sampleStruct: SampleStruct(hogeProperty: 4), sampleEnum: .hogeCase)

do {
    let dict1 = try sample.asDictionary(keyEncodingStrategy: .useDefaultKeys)
    let dict2 = try sample.asDictionary(keyEncodingStrategy: .convertToSnakeCase)

    // ä»¥ä¸‹ã¯ã©ã¡ã‚‰ã‚‚åŒã˜å‡ºåŠ›ã«ãªã‚‹ï¼ˆ Encodable & Decodable ã® Struct -> Dictionary -> Struct ã®å¤‰æ›ãŒã†ã¾ãã„ã£ã¦ã„ã‚‹ï¼‰
    print(try Sample(from: dict1, keyDecodingStrategy: .useDefaultKeys))
    print(try Sample(from: dict2, keyDecodingStrategy: .convertFromSnakeCase))
} catch {
    print("\(error)")
}
```

## Dictionary -> Struct ã®å¤‰æ›ï¼ˆã‚¨ãƒ©ãƒ¼ã®æ¤œè¨¼ï¼‰

```swift
let sample = Sample(sampleInt: 1, sampleString: "a", sampleDouble: 2.0, sampleFloat: 3.0, sampleBool: true, sampleDate: Date(), sampleStruct: SampleStruct(hogeProperty: 4), sampleEnum: .hogeCase)

do {
    let dict1 = try sample.asDictionary(keyEncodingStrategy: .useDefaultKeys)
    let dict2 = try sample.asDictionary(keyEncodingStrategy: .convertToSnakeCase)

    // ã‚ã–ã¨ã€asDictionary ã§æŒ‡å®šã—ãŸ KeyDecodingStrategy ã¨ç•°ãªã‚‹å€¤ã‚’æŒ‡å®šã—ã¦ã¿ã‚‹
    print(try Sample(from: dict1, keyDecodingStrategy: .convertFromSnakeCase)) // â† ãªãœã‹ã‚¨ãƒ©ãƒ¼ã«ãªã‚‰ãªã„
    print(try Sample(from: dict2, keyDecodingStrategy: .useDefaultKeys)) // â† ã‚¨ãƒ©ãƒ¼ã«ãªã‚‹
} catch {
    print("\(error)")
}
```

## Codable ã‚„ JSONSerialization ã‚’ä½¿ã‚ãªã„ã§ Dictionary ã«ã™ã‚‹æ–¹æ³•

`Mirror` ã‚’ä½¿ã†ã“ã¨ã§å‹ã‚’ãªã‚‹ã¹ãæ®‹ã—ãŸçŠ¶æ…‹ã§è¾æ›¸å‹ã«å¤‰æ›ã§ãã¾ã™ã€‚

```swift
public enum CaseFormat {
    case original
    case snakeCase
}

public protocol ConvertibleToDictionary {
    func asDictionary(caseFormat: CaseFormat) -> [String: Any]
}

public extension ConvertibleToDictionary {
    func asDictionary(caseFormat: CaseFormat = .original) -> [String: Any] {
        let mirror = Mirror(reflecting: self)
        var dictionary: [String: Any] = [:]

        mirror.children.forEach { child in
            guard let keyName = child.label else { return }

            switch caseFormat {
            case .original:
                dictionary[keyName] = child.value
            case .snakeCase:
                dictionary[keyName.toSnakeCase] = child.value
            }
        }

        return dictionary
    }
}

extension String {
    var toSnakeCase: String {
        let snakeCased = unicodeScalars.reduce("") { result, scalar in
            if CharacterSet.uppercaseLetters.contains(scalar) {
                return "\(result)_\(Character(scalar))"
            } else {
                return result + String(scalar)
            }
        }.lowercased()

        if snakeCased.hasPrefix("_") {
            return String(snakeCased.dropFirst())
        } else {
            return snakeCased
        }
    }
}

let sample = Sample(sampleInt: 1, sampleString: "a", sampleDouble: 2.0, sampleFloat: 3.0, sampleBool: true, sampleDate: Date(), sampleStruct: SampleStruct(hogeProperty: 4), sampleEnum: .hogeCase)

let dict1 = sample.asDictionary(caseFormat: .original)
let dict2 = sample.asDictionary(caseFormat: .snakeCase)

print(dict1)
print(dict2)
```

## .original ã§å¤‰æ›ã—ãŸ Dictionary

```swift:dict1
[
    "sampleInt": 1,
    "sampleString": "a",
    "sampleDouble": 2.0,
    "sampleFloat": 3.0,
    "sampleBool": true,
    "sampleDate": "2023-08-12 12:48:45 +0000",
    "sampleStruct": "SampleStruct(hogeProperty: 4)",
    "sampleEnum": "SampleEnum.hogeCase"
]
```

## .snakeCase ã§å¤‰æ›ã—ãŸ Dictionary

```swift:dict2
[
    "sample_int": 1,
    "sample_string": "a",
    "sample_double": 2.0,
    "sample_float": 3.0,
    "sample_bool": true,
    "sample_date": "2023-08-12 12:48:45 +0000",
    "sample_struct": "SampleStruct(hogeProperty: 4)",
    "sample_enum": "SampleEnum.hogeCase"
]
```

## ãã‚‚ãã‚‚ãªãœã“ã®ã‚ˆã†ãªã“ã¨ã‚’ã‚„ã‚ŠãŸã„ã®ã‹ï¼Ÿ

Protocol Buffers ã® [`google.protobuf.Value`](https://github.com/protocolbuffers/protobuf/blob/main/src/google/protobuf/struct.proto#L62) ã§æ‰±ãˆã‚‹å‹ ã¯ `NullValue`, `double`, `string`, `bool`, `Struct`, `ListValue` ã®ã¿ã§ã€`map<string, google.protobuf.Value>` ã« Swift ã® Struct ã‚’è¾æ›¸å‹ã«å¤‰æ›ã™ã‚‹ã¨ãã«ä½¿ã†ã“ã¨ãŒç›®çš„ã§ã—ãŸã€‚

ãã—ã¦ã€ä»¥ä¸‹ã®ã‚ˆã†ãªå‡¦ç†ã‚’æ›¸ãéš›ã« `JSONSerialization` ã‚’ä½¿ã†ã¨å‹æƒ…å ±ãŒå¤±ã‚ã‚Œã¦ã—ã¾ã„ã€æ€ã£ãŸã‚ˆã†ãªå¤‰æ›ã‚’ã—ã¦ãã‚Œãªã‹ã£ãŸã®ã§ã€`Mirror` ã§æ›¸ãã“ã¨ã«ãªã‚Šã¾ã—ãŸã€‚

```swift
import Foundation
import SwiftProtobuf

var toProtoBufValueDictionary: [String: Google_Protobuf_Value] {
    asDictionary(caseFormat: .snakeCase).mapValues { value in
        var protoValue = Google_Protobuf_Value()
        switch value {
        case let intValue as Int:
            protoValue.numberValue = Double(intValue)
        case let doubleValue as Double:
            protoValue.numberValue = doubleValue
        case let floatValue as Float:
            protoValue.numberValue = Double(floatValue)
        case let stringValue as String:
            protoValue.stringValue = stringValue
        case let dateValue as Date:
            protoValue.stringValue = ISO8601DateFormatter.sharedWithFractionalSeconds.string(from: dateValue)
        case let boolValue as Bool:
            protoValue.boolValue = boolValue
        default:
            assertionFailure("Unexpected type encountered while converting to Google_Protobuf_Value")
        }
        return protoValue
    }
}

extension ISO8601DateFormatter {
    static let sharedWithFractionalSeconds: ISO8601DateFormatter = {
        let formatter = ISO8601DateFormatter()
        formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
        formatter.timeZone = TimeZone.current
        return formatter
    }()
}
```

# ã¾ã¨ã‚

`JSONSerialization` ã¯å‹ã®å¤‰æ›´ã‚’å¼•ãèµ·ã“ã™å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€ç›´æ¥è¾æ›¸å¤‰æ›ã‚’è¡Œã†ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚‚æ¤œè¨ã—ãŸã»ã†ãŒã„ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚