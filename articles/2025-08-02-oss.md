---
title: "無職が Claude Code を使って 3 週間かけて OSS ライブラリを開発したけど誰も使ってくれなかった話"
emoji: "🤖"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["OSS", "Claude Code", "TypeScript", "AI開発"]
published: false
---

# 無職が Claude Code を使って 3 週間かけて OSS ライブラリを開発したけど誰も使ってくれなかった話

## 概要
無職がClaude Codeを使ってChatGPTとの会話履歴をMarkdownに変換するツールを開発したが誰も使ってくれなかった話

リリースして1週間、XでエゴサしたりGitHub のStar数など確認して0件だったので、さすがにこれは誰も使っていないだろうとなり、さすがにネタにしないとOSSも報われないので投稿するに至った次第です。

## 記事の趣旨説明
また、このOSS開発を通じて、また、これを作るためにTypeScriptを勉強した過程でClaude Codeをかなり使い倒したので、そこから得た知見についてつらつらと書いていきたいと思います。

客観的な事実から基づくことを書いているわけではなく、完全に私個人の感想を述べているだけなので、その点についてはご了承いただきたいです。まあポエムだと思ってください。

## タイトル詐欺の告白
正直に言うと、この記事はちょっとタイトル詐欺です。「誰も使ってくれなかった話」と言いながら、実際の内容の大半はClaude Codeを使い倒して得た実践的なTips集になっています。でも、誰も使ってくれなかったのは本当の話なので、そこはご容赦ください。失敗談を期待してクリックした方には申し訳ないですが、せっかくなのでClaude Codeの知見も持って帰ってください。

## 開発環境

**開発期間**
- 3週間土日平日問わずClaude CodeがUsage Limitになるまでフル稼働
- もしAPIを直接使っていたら$3000（45万円）ほどかかっていた計算

**AI Subscription**
- Claude Code Max Plan $100/月
- ChatGPT plus $20/月
- GitHub Copilot $10/月

**使用AIモデル**
- ClaudeのモデルはSonnet4では物足りなく感じることが多かったのででほぼ全ての作業はOpus4を使うことにしました

**前提知識**
- モバイルエンジニア
- TypeScript 2025年6月から学習中
- 初npmパッケージリリース
- 初homebrewパッケージでのリリース
- 無職（現在案件探し中）

## 作ったもの
https://github.com/sugurutakahashi-1234/ai-chat-md-export

## 作ろうと思ったきっかけ
自分のAIとの会話履歴を全部Markdownに出力してObsidianに第二の脳を作ろうと意気込んでいて突発的に作ったスクリプトを汎用化してリリースするに至った。
あと現在無職でTypeScriptの勉強に良い機会だと思ったため

## このツールに対しての本質的な感想

### 当初の期待と現実
そもそもClaudeとChatGPTをMarkdownに変換しようとした目的はObsidianで第二の脳を作ったり、今までClaudeやChatGPTと対話した履歴から色々な知見が溜まっているためそれをまとめたいと思いました。しかし、実際に出力したやりとりを見てみても、あのときこんなことしたなーと思い出にふけることはできますが、そこまでよいインサイトになりそうにありませんでした。具体的にはまたAIと相談すれば得られる出力でした。

### ツールの存在価値について
また、AIと相談した結果としてソースコードがあるので、自分が作ったソースコードにそのAIとの相談した最終成果物で、そこに思い出や本質がつまっています。AIとのやりとりに本質はなく、しかもそれは時が立てば古い情報だったり、AIの性能が進化しているので、また疑問になったタイミングでまたAIと相談すれば良いと思っているため、本質的にこのツールはいらないという結論に私個人としてはなりました。

長々書きましたが本質的にそもそも存在価値のないユースケースを補助するツールを作成して使われなかったということです。

## 作らなければよかった機能一覧

### 過剰な機能実装
もし求められていないことがわかっていたのであれば、以下の機能は作らなかったでしょう。

- 日本語と中国語のreadme（維持が難しいのと簡単な修正にも結構トークンを消費している印象）
- homebrew対応（npm対応だけでよかった）
- windows対応（npm対応だけでよかった）
- ファイルの分割モードとまとめるモードの実装
- 出力のquietモードの設定

### 学習としての価値
しかしながら、そもそも自己学習もテーマであったので完全に作らなければよかったということもないのでよしとしましょう（負け惜しみ）
作らなくてよかった機能はたくさんあるが触りたかった技術があるのでそれはとてもモチベーションになりました。
（そもそもTypeScriptという新しい技術にどっぷりさわれたこと。npm、homebrew、GitHub Actionsでのリリースなど）

## Claude Code開発で得た実践的な知見

### テストについて
テストコードが首を絞めるのでテストは最小限にさせておいた方がいいです。
テストコードの作成コストが安いのでつい作りがちだけどリファクタリングした際にテストコードを通すようにAIが無意味なコードを保守したり破壊的修正を回避してしまうのでやめた方がいいです。
テストピラミッドとは逆の考えで、詳細なユニットテストを作らせるとそれに引っ張られて本質的な統合テストを設置して進めていったほうがいい。

### テストカバレッジの罠
カバレッジを設定するとかなり意味のないテストをつけがちなので採用しない方がいいと感じました。
これは上記と同じようにカバレッジを維持するために意味のないテストを書いて、リファクタリング時もそれを維持するためです。

### 継ぎ足し開発の限界
Claude Codeで最初に大まかな機能を作って、あとから継ぎ足しで機能を継ぎ足し継ぎ足しで追加していくとたちまち昔書いたコードが動かなくなりました。
そこで、テストコードを書かせることで防げるかと思ったのですが、細かいテストコードを書いていると先述したようにそれが逆に負債になってしまってかなりドツボにハマっていきました。

### クリーンアーキテクチャの導入
Claude Codeはクリーンアーキテクチャもといレイヤードアーキテクチャはわりかし得意のように感じました。
そこで、アーキテクチャを導入することにしたのですが、クリーンアーキテクチャについての知識は以前経験したことがあったので、導入してみたところClaude Codeの理解度が高くわりと簡単にリアーキテクチャしてくれたのと、それから機能追加した際も既存のコードをあまり破壊せずに機能を追加してくれるようになりました。
もちろん全自動にリアーキテクチャをやってくれたわけではなく、私の方でもかなり指示をしてクリーンアーキテクチャは実現されたのですが、そこそこアーキテクチャ違反をせずにやってくれる印象です。

### アーキテクチャ違反の検知方法
さらに静的解析ツールなどを使って依存図を自動生成して、それを読み込ませてから作業をさせるのはとても友好的でした。
特にアーキテクチャ違反を修正させたりする作業にはとても効果的でした。
また、クリーンアーキテクチャではなく、より簡易的な依存性の逆転をさせないようレイヤードアーキテクチャでも同じようにClaude Codeの理解力は高いように感じました。

### リファクタリング
雑に何のコンテキストも与えずにリファクタリングさせるとあまり期待通りのリファクタリングをしてくれないことが多いです。
そこでお勧めなのが、planモードを完遂し切ったあとにすぐにその修正についてリファクタリングさせることです。Claude Codeはちょっとしたタスクでもplanモードでやったほうが精度がでるので、planモードを活用してタスクを実行し、その直後にリファクタリングを行うのが効果的です。
今実装した内容について、振り返らさせると割と良いリファクタリングをしてくれる可能性が高いことが多かったです。
これは同一コンテキスト上で行うことが意味あるかもしれないので、もしリファクタリングしたい場合は実装してすぐにこまめに行うことをお勧めします。

### CLAUDE.mdとGit Hooksでのルール管理

#### CLAUDE.mdについて
やってほしいこと、やってほしくないことをCLAUDE.mdに書いたとしてもそれを守ってくれないことは多々あります。
ただ、作業の直前でCLAUDE.mdをコンテキストに与えるとそのルールを守ってくれる確率は高いです。
直前に読み込ませたコンテキストは強く覚えてくれているのだろうと思います。
しかしながら、指示の前に繰り返し毎回必要なコンテキストやCLAUDE.mdを与えたりするのは辛いです。

#### コード内コメントの活用
なので、修正してしまいそうなところに先読みして、コメントとして残しておくとよいです。
例えばtsconfig.jsonで強めのTypeScriptを設定しているとlinterが走った際のワーニングやエラーの解決時にコード側の解決を諦めてtsconfig.jsonの方を修正して、linterを通ったことにすることがでてくるのをあらかじめtsconfig.json側にlinterを通すための修正してはいけない旨のコメントを残しておくとそのようなことを行わなくなります。

#### Git Hooksでのルール実装
そのかわりに、huskyなどのGitHub操作をトリガーに任意のスクリプトを走らすことのできるhooksでpre-commitやpre-push、commit-msg、post-checkoutを定義してそこで、linter,フォーマッターやtest,バリデーション、コミットメッセージルール、ブランチ名などその場その場での必要な処理を噛ませることによってルールを守らせて、それを検知することにしました。

#### ルール定義よりもエラーメッセージ
それぞれのルールを定義して、それをClaudeに読ませて実行してもらうこともやっていたのですが、それはコンテキストや時間を食ってしまうことがわかったので、その辺のルールをガチガチに自然言語で指定するよりhuskyによるhooksでひっかけてそのときのエラーメッセージでルールを教えたほうがコンテキストや時間をかけずに通過してくれる感じがあります。

#### ローカル検証の重要性
イメージとしてはGitHub Actionsで検証していたようなことは全部ローカルのコミットやpushの段階で全部検証するようにしたほうがスムーズに開発できる印象でした。
もちろんClaude Codeのhooksでも良いと思いますが、あんまりClaude Codeまわりの設定は個人で色々あると思うので、GitHub管理したくないのでその辺はhuskyによせるようにしました。

#### アーキテクチャルールの自動化
また、そのような局所的ではないアーキテクチャのルールはファイルの依存関係を抽象化した依存関係のMermaid図を自動生成するSDKなどをhuskyでpre-commitで生成するようにして、その変更をpre-commitでチェックして、commit時に引っ掛けたりして、アーキテクチャ違反をしていた場合に修正させるようにしたほうが良いです。
また、その際のメッセージをClaude Codeが読み取るの前提に参照すべきファイルなどを出力するように指定しておくと、こちらがわざわざ指示しなくても自動的に修正してくれるようになります。

### コンテキストの管理方法
Claude Code にアーキテクチャやライブラリの導入理由などをARD（Architecture Decision Record）をGitHub 管理してそれを各開発に読み込ませるような仕組みを導入して、どれをコンテキストとして指定して指示をさせていたことがあったのですが、メンテナンス含めてうまくいきませんでした。

### ADRが失敗した理由
そもそもADRをメンテナンスしていくということ自体が間違っているのかもしれませんが、実装していくのに伴って、こう実装したほうがいいというのはどんどん移り変わっていきますし、その移り変わりをARDに反映されるをつい忘れてしまいます。
また、そしてそのメンテナンスをしていないARDをリポジトリ管理していると、全然意図していないタイミングでClaude Codeが検索に引っ掛けて読んでしまうことがあって、意図していない作業をしてしまうことが結構ありました。
メンテナンスされないドキュメントは人間だけではなくClaude Codeも混乱に陥れるということですね。
なので、修正が漏れそうなドキュメントはそもそも作らないのが吉のように思いました。
結果的にいわゆる自然言語でのルールはCLAUDE.mdの１つのファイルに収まるレベルのドキュメントしか残さないことにしました。
私はやったことないのですが、ルールファイルを各ディレクトリに配置して、そこのファイルを修正するときには必ず読むようにするというようなアプローチも私は同様にメンテナンスを維持しきれれないというような問題点があると思います。
あとは前述したのですが、コード側にルールに近いようなコメントを残すようにしました。

## Claude Code開発のワークフロー

### Claude Codeに支配される生活
5時間サイクルに生活リズムを合わせた話。朝起きてすぐにClaudeにおはようと言って5時間サイクルを開始させるのが習慣になった。

### 1日3回サイクルの限界
また、1日に4回のUsageLimitを使い切るサイクルを回そうと思ったのですが、最後の4サイクル目をやっているときは9時-14時-19時-24時のサイクルで続けると24時スタートになってしまってUsageLimitを頑張って使っても開発終了が深夜3時とかになってしまって健康を害するので、1日3回が限度だということも学びました。

### 夜間作業の落とし穴
また夜になるとだんだん集中力が下がってくるのでClaude Codeが書いたコードをよく確認せずに何でも受け入れがちになってしまいます。特にリファクタリングはお勧めしません。
結果として、夜に受け入れてしまった謎なコードを翌朝になって困らされるのはよくあります。
集中力が下がっている夜はできるだけ頭を使わなく、コードに関係ないような作業を残しておいてそれをしていくのをお勧めします。
あとはClaude Codeも使い切らないと勿体無いという精神も時には我慢が必要になります。

### Claude Code待ち時間の工夫
auto-acceptしている時に席を立つとスイッチングコストが尋常じゃないので席を立たずに次の質問をメモ帳で作成しながら進めてなるべくPCの前から離れなかったり、今依頼している作業からプログラミングから意識を離さないようにした。

### リアルタイムコードレビューの手法
クロードコードが自動で走っている時に変更したコードをVSCode上でgit diffを表示しながら、変更をどんどんgit addするようにすれば、リアルタイムコードレビューができかつ、Claudeの動いている時間を有効活用できながら意識を維持することができるのでとてもお勧めである

### 複数同時作業の現実性について
5時間使いきれない時はClaude Codeを2つ立ち上げて2つ別の作業をさせたが、片方が開発中にtestができなかったりするし、そもそも2つ同時に使うような作業は私個人としては人間の脳がボトルネックになって、片方では長時間かかる作業をやらせて、別で抱えていた単純な作業をやらせるということも試みました。
正直Claude CodeをひとつのPCで走らせて指示しながら作業をするのはあまり現実的ではないと思いました。一回の指示でもっと精度よく長時間走ってくれるようになってから考えれば良いと思いました。
Git Worktreeを使えば並行して作業させられるということですが、これも脳がボトルネックになると思いますが、やったことないので何とも言えません。
人間の脳は2つのことを同時に考えることが得意ではないらしいので。

### プラン選択について（Claude Max プラン 20x $200の検討）
Claude maxプランは5xのプランで毎日少なくとも3回はUsageリミットまで使っており一時期20xのプラン(200ドル)まで、あげようと思いましたが、あげなくて正解な部分があります。

### 締め切り効果の活用
理由は一人でどんなに頑張ってOpus走らせても2時間でUsageLimitがくるので、とても5時間では使いきれないのと、ちょうどこの5時間で使い切らないと持ったない精神が働いたほうがこの締め切り効果で、使い切るようなリズムの良い開発が生まれるのでむしろ都合良くなっている。

### ChatGPT o3との使い分け
逆にChatGPTのplusプランのo3を余しているが、Claudeのように5時間のサイクルではなくて、1週間単位でのUsageLimitなので締め切り効果が味わえず使いきれていないので、改善していきたいところです。

### o3の使い所の難しさ
もっとo3をベースに仕様や実装方針を決める方向で進めたいです。Opus4でも仕様の検討や採用するライブラリの選定をさせると物足りなさを感じたので、そのあたりのより知性が必要になるようなユースケースではChatGPT o3で相談していくことが必要のように感じました。しかし、コードのコンテキストを全部読ませやすいClaudeの方が実装方針を決めるのもその点が全然有利なので、o3の使い所が難しいのは否めません。

## 学習ツールとしてのClaude Code
AIを使った方が考えないけど学習効率がよいのは確かです。TypeScriptほぼ未経験の状態で3週間でOSSは作れるぐらいの勉強効率は提供してくれます。
イメージとしてはこれはヒカルの碁でいうところのサイがいる状態と同じです。サイがいるなら碁は教えてもらったほうがいいです。
サイにずっと打たせた方が無双できるのになんで、ヒカルはサイに打たせないんだよ!って
昔は思っていたのですが、サイがいるんだったら、私も碁をやってみようかなと思う気持ちが十分わかるのでヒカルの気持ちが今なら頷けます。（ヒカルの碁はほんとにお勧めです）

## バイブコーディング時代の本質

### エンジニアリングの普遍的な課題
Claude Codeの生じた課題は別にバイブコーディングならではなのか？そうではないと思います。
更新が追いついていないドキュメントで混乱させられたり、カバレッジ維持するために本質的には無意味なテストコードを書いてしまったり、自分が書いたテストコードを維持できなかったり、書いたテストコードを通すように無意味な機能を残し続けたり、夜に書いて作業を早く終わらせたいからとマージしたコードに翌朝困らされたり、別にこれはバイブコーディング以前から発生していたことです。
開発スピードは確かに上がるかもしれませんが、エンジニアリングの本質的な悩みや課題は別にバイブコーディング以前も以降も変わらないのだと感じます。
であるならば、まだ、しばらく過去の遺産を材料に飯を食っていけそうです（本当でしょうか？）

### 技術の陳腐化と継続的学習
ここまで色々Claude CodeのTips的な話を多くしてきましたが、正直この知識はすぐに陳腐化すると思います。

### planモードの登場で学んだこと
実際に経験したのですが、Claude Codeのplanモードの登場前にgithub issueにステップを起票させて、それを逐次確認して更新しながらタスクを漏れなく実施させるようなプロンプトを時間をかけて作って、バイブコーディングの真のやり方を発明した、これで勝つるとか思っていたのですが、速攻でplanモードがでてきて一瞬でその優位性（？）が陳腐化しました。
他にも作業の終了時に音を鳴らすCLAUDE.mdの記述方法なども盛り上がりを見せ、私もそれを取り入れていたのですが、Anthropic公式がhooksの機能をリリースして、CLAUDE.mdへのそのような記述もする必要がなくなりました。
2025年8月現在、Kiroでのスペック(spec)での開発が盛り上がりを見せておりますが、そして、これもおそらくAnthropic公式が早々にspecモードを出すことでしょう。

### 会社制約下のエンジニアへのメッセージ
ここで言いたいのはすぐに陳腐化するから無駄だということではなくて、このバイブコーディング時代に今日一番詳しいということよりも、明日も興味をもって勉強できることが最大の武器であるということです。
おそらく最近のバイブコーディング時代に会社の制約などあって自由に開発にAIを使えずに自分が取り残されていて不安に思っている人が多くいると思います。

### 継続的学習の重要性
ですが、結局AIによって開発効率や学習効率がどんどん高まっている時代では、また来月になったら新しい学習サポートAIがとか、新しいClaude Codeのモードだとか、新しいエディターなどが次々に出てきて、ここで紹介しているような小手先のTipsや便利プロンプトや方法を持っている人のスキルはすぐに陳腐化するでしょう。
なので、今遅れているからと言って焦る必要はなく、また明日新しいことをずっと取り入れる姿勢さえ忘れてなければ、それできっと大丈夫なんだと思っています。
逆にその手のTipsを知って今とてもAIのツールを使いこなしているからといってあぐらをかいているとすぐに足元すくわれるので気をつけたいです。（まさにこのようなTips記事を書いているような人が一番怪しいと思っています。）

## 振り返りと結論

### そもそもとして誰も使ってくれなかったことは問題なのか?
資本主義的には問題なのでしょうけど個人的にはこれだけ教訓があったのだから全然問題ないです。
むしろ、変な勘違いしなくてよかったかもしれません。
一方で、いっぱい使ってくれてメンテに明け暮れることで初めてわかることだったりがあると思うので、その機会損失をしているので大負けかもしれませんね。
人生何があるかわかりません。ただ自分の学習のためだけのサンドボックス的なリポジトリでの開発で3週間フルフルに使うようなモチベーションは維持できないので、ただの学習であっても、少し遠回りにはなってしまいますが、OSS開発というものはよい学習の選択肢かもしれません。

### 得た教訓
- バイブコーディングでの悩みは昔からあるエンジニアリングの悩みと変わらない
- 使ったことない技術を触るのは楽しい
- OSS開発は勉強になる
- OSS開発はモチベが維持しやすい
- OSS開発しても使ってくれるとは限らない

### 結果として良かったこと
- Claude CodeのOpusが出すTypeScriptの提案に対して改善提案を突っ込めるようになるレベルまでに上がったこと
- OSS開発を経験できたこと
- npm リリースを経験できたこと
- homebrewリリースを経験できたこと
- この記事に書いてあるような学びを得たこと